// Generated by dts-bundle-generator v9.5.1

import { StringStream } from '@codemirror/language';
import { SearchQuery } from '@codemirror/search';
import { ChangeDesc, EditorSelection, Extension } from '@codemirror/state';
import { EditorView, ViewUpdate } from '@codemirror/view';

declare function initVim(CM: typeof CodeMirror): {
	enterVimMode: (cm: CodeMirror) => void;
	leaveVimMode: (cm: CodeMirror) => void;
	buildKeyMap: () => void;
	getRegisterController: () => {
		registers: {
			[x: string]: {
				keyBuffer: string[];
				/** @type {InsertModeChanges[]} */
				insertModeChanges: InsertModeChanges[];
				/** @type {string[]}*/
				searchQueries: string[];
				linewise: boolean;
				blockwise: boolean;
				/** @arg {string} [text] @arg {boolean} [linewise] @arg {boolean } [blockwise] */
				setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
				/** @arg {string} text @arg {boolean} [linewise] */
				pushText(text: string, linewise?: boolean): void;
				/** @arg {InsertModeChanges} changes */
				pushInsertModeChanges(changes: InsertModeChanges): void;
				/** @arg {string} query */
				pushSearchQuery(query: string): void;
				clear(): void;
				toString(): string;
			};
		};
		unnamedRegister: {
			keyBuffer: string[];
			/** @type {InsertModeChanges[]} */
			insertModeChanges: InsertModeChanges[];
			/** @type {string[]}*/
			searchQueries: string[];
			linewise: boolean;
			blockwise: boolean;
			/** @arg {string} [text] @arg {boolean} [linewise] @arg {boolean } [blockwise] */
			setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
			/** @arg {string} text @arg {boolean} [linewise] */
			pushText(text: string, linewise?: boolean): void;
			/** @arg {InsertModeChanges} changes */
			pushInsertModeChanges(changes: InsertModeChanges): void;
			/** @arg {string} query */
			pushSearchQuery(query: string): void;
			clear(): void;
			toString(): string;
		};
		/**
		 * @param {string | null | undefined} registerName
		 * @param {string} operator
		 * @param {string} text
		 * @param {boolean} [linewise]
		 * @param {boolean} [blockwise]
		 */
		pushText(registerName: string | null | undefined, operator: string, text: string, linewise?: boolean, blockwise?: boolean): void;
		/**
		 * Gets the register named @name.  If one of @name doesn't already exist,
		 * create it.  If @name is invalid, return the unnamedRegister.
		 * @arg {string} [name]
		 */
		getRegister(name?: string): {
			keyBuffer: string[];
			/** @type {InsertModeChanges[]} */
			insertModeChanges: InsertModeChanges[];
			/** @type {string[]}*/
			searchQueries: string[];
			linewise: boolean;
			blockwise: boolean;
			/** @arg {string} [text] @arg {boolean} [linewise] @arg {boolean } [blockwise] */
			setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
			/** @arg {string} text @arg {boolean} [linewise] */
			pushText(text: string, linewise?: boolean): void;
			/** @arg {InsertModeChanges} changes */
			pushInsertModeChanges(changes: InsertModeChanges): void;
			/** @arg {string} query */
			pushSearchQuery(query: string): void;
			clear(): void;
			toString(): string;
		};
		isValidRegister(name: any): name is string;
		shiftNumericRegisters_(): void;
	};
	resetVimGlobalState_: () => void;
	getVimGlobalState_: () => {
		macroModeState: {
			latestRegister: string | undefined;
			isPlaying: boolean;
			isRecording: boolean;
			/** @type {string[]}*/
			replaySearchQueries: string[];
			onRecordingDone: ((newVal?: string) => void) | undefined;
			lastInsertModeChanges: InsertModeChanges;
			exitMacroRecordMode(): void;
			/**
			 * @arg {CodeMirror} cm
			 * @arg {string} registerName
			 */
			enterMacroRecordMode(cm: CodeMirror, registerName: string): void;
		};
		registerController: {
			registers: {
				[x: string]: {
					keyBuffer: string[];
					/** @type {InsertModeChanges[]} */
					insertModeChanges: InsertModeChanges[];
					/** @type {string[]}*/
					searchQueries: string[];
					linewise: boolean;
					blockwise: boolean;
					/** @arg {string} [text] @arg {boolean} [linewise] @arg {boolean } [blockwise] */
					setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
					/** @arg {string} text @arg {boolean} [linewise] */
					pushText(text: string, linewise?: boolean): void;
					/** @arg {InsertModeChanges} changes */
					pushInsertModeChanges(changes: InsertModeChanges): void;
					/** @arg {string} query */
					pushSearchQuery(query: string): void;
					clear(): void;
					toString(): string;
				};
			};
			unnamedRegister: {
				keyBuffer: string[];
				/** @type {InsertModeChanges[]} */
				insertModeChanges: InsertModeChanges[];
				/** @type {string[]}*/
				searchQueries: string[];
				linewise: boolean;
				blockwise: boolean;
				/** @arg {string} [text] @arg {boolean} [linewise] @arg {boolean } [blockwise] */
				setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
				/** @arg {string} text @arg {boolean} [linewise] */
				pushText(text: string, linewise?: boolean): void;
				/** @arg {InsertModeChanges} changes */
				pushInsertModeChanges(changes: InsertModeChanges): void;
				/** @arg {string} query */
				pushSearchQuery(query: string): void;
				clear(): void;
				toString(): string;
			};
			/**
			 * @param {string | null | undefined} registerName
			 * @param {string} operator
			 * @param {string} text
			 * @param {boolean} [linewise]
			 * @param {boolean} [blockwise]
			 */
			pushText(registerName: string | null | undefined, operator: string, text: string, linewise?: boolean, blockwise?: boolean): void;
			/**
			 * Gets the register named @name.  If one of @name doesn't already exist,
			 * create it.  If @name is invalid, return the unnamedRegister.
			 * @arg {string} [name]
			 */
			getRegister(name?: string): {
				keyBuffer: string[];
				/** @type {InsertModeChanges[]} */
				insertModeChanges: InsertModeChanges[];
				/** @type {string[]}*/
				searchQueries: string[];
				linewise: boolean;
				blockwise: boolean;
				/** @arg {string} [text] @arg {boolean} [linewise] @arg {boolean } [blockwise] */
				setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
				/** @arg {string} text @arg {boolean} [linewise] */
				pushText(text: string, linewise?: boolean): void;
				/** @arg {InsertModeChanges} changes */
				pushInsertModeChanges(changes: InsertModeChanges): void;
				/** @arg {string} query */
				pushSearchQuery(query: string): void;
				clear(): void;
				toString(): string;
			};
			isValidRegister(name: any): name is string;
			shiftNumericRegisters_(): void;
		};
		searchHistoryController: {
			/**@type {string[]} */
			historyBuffer: string[];
			iterator: number;
			initialPrefix: string | null;
			/**
			 * the input argument here acts a user entered prefix for a small time
			 * until we start autocompletion in which case it is the autocompleted.
			 * @arg {string} input
			 * @arg {boolean} up
			 */
			nextMatch(input: string, up: boolean): string | undefined;
			/** @arg {string} input */
			pushInput(input: string): void;
			reset(): void;
		};
		jumpList: ReturnType<() => {
			/**@type{Pos|undefined} */
			cachedCursor: Pos | undefined;
			add: (cm: CodeMirror, oldCur: Pos, newCur: Pos) => void;
			find: (cm: CodeMirror, offset: number) => {
				line: number;
				ch: number;
				sticky?: string;
			} | null | undefined;
			move: (cm: CodeMirror, offset: number) => {
				cm: CodeMirror;
				id: number;
				offset: number | null;
				assoc: number;
				clear(): void;
				find(): {
					line: number;
					ch: number;
					sticky?: string;
				} | null;
				update(change: import("@codemirror/state").ChangeDesc): void;
			} | undefined;
		}>;
		exCommandHistoryController: {
			/**@type {string[]} */
			historyBuffer: string[];
			iterator: number;
			initialPrefix: string | null;
			/**
			 * the input argument here acts a user entered prefix for a small time
			 * until we start autocompletion in which case it is the autocompleted.
			 * @arg {string} input
			 * @arg {boolean} up
			 */
			nextMatch(input: string, up: boolean): string | undefined;
			/** @arg {string} input */
			pushInput(input: string): void;
			reset(): void;
		};
		lastCharacterSearch: {
			increment: number;
			forward: boolean;
			selectedCharacter: string;
		};
		query?: any;
		isReversed?: boolean;
		lastSubstituteReplacePart: any;
		searchQuery?: null;
		searchIsReversed?: boolean;
	};
	maybeInitVimState_: (cm: CodeMirror) => vimState;
	suppressErrorLogging: boolean;
	InsertModeKey: {
		new (keyName: string, e: KeyboardEvent): {
			keyName: string;
			key: string;
			ctrlKey: boolean;
			altKey: boolean;
			metaKey: boolean;
			shiftKey: boolean;
		};
	};
	/**@type {(lhs: string, rhs: string, ctx: string) => void} */
	map: (lhs: string, rhs: string, ctx: string) => void;
	/**@type {(lhs: string, ctx: string) => any} */
	unmap: (lhs: string, ctx: string) => any;
	/**@type {(lhs: string, rhs: string, ctx: string) => void} */
	noremap: (lhs: string, rhs: string, ctx: string) => void;
	/**@arg {string} [ctx]} */
	mapclear: (ctx?: string) => void;
	langmap: (langmapString: any, remapCtrl: any) => void;
	vimKeyFromEvent: (e: KeyboardEvent, vim?: vimState) => string | undefined;
	setOption: (name: string, value: any, cm?: CodeMirrorV, cfg?: {
		scope?: any;
	} | undefined) => Error | undefined;
	getOption: (name: string, cm?: CodeMirrorV, cfg?: {
		scope?: any;
	} | undefined) => any;
	defineOption: {
		/**
		 * @overload
		 * @arg {string} name
		 * @arg {boolean|null|undefined} defaultValue
		 * @arg {'boolean'} type
		 * @arg {string[]|null} [aliases]
		 * @arg {import("./types").booleanOptionCallback} [callback]
		 * @returns {void}
		 */
		(name: string, defaultValue: boolean | null | undefined, type: "boolean", aliases?: string[] | null | undefined, callback?: booleanOptionCallback | undefined): void;
		/**
		 * @overload
		 * @arg {string} name
		 * @arg {number|null|undefined} defaultValue
		 * @arg {'number'} type
		 * @arg {string[]|null} [aliases]
		 * @arg {import("./types").numberOptionCallback} [callback]
		 * @returns {void}
		 */
		(name: string, defaultValue: number | null | undefined, type: "number", aliases?: string[] | null | undefined, callback?: numberOptionCallback | undefined): void;
		/**
		 * @overload
		 * @arg {string} name
		 * @arg {string|null|undefined} defaultValue
		 * @arg {'string'} type
		 * @arg {string[]|null} [aliases]
		 * @arg {import("./types").stringOptionCallback} [callback]
		 * @returns {void}
		 */
		(name: string, defaultValue: string | null | undefined, type: "string", aliases?: string[] | null | undefined, callback?: stringOptionCallback | undefined): void;
	};
	/**@type {(name: string, prefix: string|undefined, func: ExFn) => void} */
	defineEx: (name: string, prefix: string | undefined, func: ExFn) => void;
	/**@type {(cm: CodeMirror, key: string, origin: string) => undefined | boolean} */
	handleKey: (cm: CodeMirror, key: string, origin: string) => undefined | boolean;
	multiSelectHandleKey: (cm_: CodeMirror, key: string, origin: string) => boolean | undefined;
	/**
	 * This is the outermost function called by CodeMirror, after keys have
	 * been mapped to their Vim equivalents.
	 *
	 * Finds a command based on the key (and cached keys if there is a
	 * multi-key sequence). Returns `undefined` if no key is matched, a noop
	 * function if a partial match is found (multi-key), and a function to
	 * execute the bound command if a a key is matched. The function always
	 * returns true.
	 */
	/**@type {(cm_: CodeMirror, key: string, origin?: string| undefined) => (() => boolean|undefined) | undefined} */
	findKey: (cm_: CodeMirror, key: string, origin?: string | undefined) => (() => boolean | undefined) | undefined;
	/**@type {(cm: CodeMirrorV, input: string)=>void} */
	handleEx: (cm: CodeMirrorV, input: string) => void;
	defineMotion: (name: string, fn: MotionFn) => void;
	defineAction: (name: string, fn: ActionFn) => void;
	defineOperator: (name: string, fn: OperatorFn) => void;
	mapCommand: (keys: string, type: string, name: string, args: any, extra: {
		[x: string]: any;
	}) => void;
	_mapCommand: (command: vimKey) => void;
	defineRegister: (name: string, register: {
		keyBuffer: string[];
		/** @type {InsertModeChanges[]} */
		insertModeChanges: InsertModeChanges[];
		/** @type {string[]}*/
		searchQueries: string[];
		linewise: boolean;
		blockwise: boolean;
		/** @arg {string} [text] @arg {boolean} [linewise] @arg {boolean } [blockwise] */
		setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
		/** @arg {string} text @arg {boolean} [linewise] */
		pushText(text: string, linewise?: boolean): void;
		/** @arg {InsertModeChanges} changes */
		pushInsertModeChanges(changes: InsertModeChanges): void;
		/** @arg {string} query */
		pushSearchQuery(query: string): void;
		clear(): void;
		toString(): string;
	}) => void;
	exitVisualMode: (cm: CodeMirrorV, moveHead?: boolean) => void;
	exitInsertMode: (cm: CodeMirrorV, keepCursor?: boolean) => void;
};
export type Vim = ReturnType<typeof initVim>;
export type vimState = {
	onPasteFn?: () => void;
	sel: {
		head: Pos;
		anchor: Pos;
	};
	insertModeReturn: boolean;
	visualBlock: boolean;
	marks: {
		[mark: string]: Marker;
	};
	visualMode: boolean;
	insertMode: boolean;
	pasteFn?: any;
	lastSelection: {
		anchorMark: Marker;
		headMark: Marker;
		visualLine: boolean;
		visualBlock: boolean;
		visualMode: boolean;
		anchor: Pos;
		head: Pos;
	};
	searchState_?: SearchStateInterface;
	lastEditActionCommand: actionCommand | void;
	lastPastedText?: string;
	lastMotion?: MotionFn | null;
	options: {
		[optionName: string]: vimOption;
	};
	lastEditInputState: InputStateInterface | void;
	inputState: InputStateInterface;
	visualLine: boolean;
	insertModeRepeat?: number;
	lastHSPos: number;
	lastHPos: number;
	wasInVisualBlock?: boolean;
	insertEnd?: Marker;
	status: string;
	exMode?: boolean;
	mode?: string;
	expectLiteralNext?: boolean;
};
export type Marker = ReturnType<CodeMirror["setBookmark"]>;
export type Pos = {
	line: number;
	ch: number;
	sticky?: string;
};
export interface CM5RangeInterface {
	anchor: Pos;
	head: Pos;
}
export type SearchArgs = {
	forward?: boolean;
	toJumplist?: boolean;
	wholeWordOnly?: boolean;
	querySrc?: string;
};
export type OperatorArgs = {
	repeat?: number;
	forward?: boolean;
	linewise?: boolean;
	fullLine?: boolean;
	registerName?: string | null;
	indentRight?: boolean;
	toLower?: boolean;
	shouldMoveCursor?: boolean;
	selectedCharacter?: string;
	lastSel?: {
		head: Pos;
		anchor: Pos;
		visualLine: boolean;
		visualBlock: boolean;
	};
	keepCursor?: boolean;
};
export type CodeMirrorV = CodeMirror & {
	state: {
		vim: vimState;
	};
};
export type OperatorFn = (cm: CodeMirrorV, args: OperatorArgs, ranges: CM5RangeInterface[], oldAnchor: Pos, newHead?: Pos) => Pos | void;
export type ActionArgsPartial = {
	repeat?: number;
	forward?: boolean;
	head?: Pos;
	position?: string;
	backtrack?: boolean;
	increase?: boolean;
	repeatIsExplicit?: boolean;
	indentRight?: boolean;
	selectedCharacter?: string;
	after?: boolean;
	matchIndent?: boolean;
	registerName?: string;
	isEdit?: boolean;
	linewise?: boolean;
	insertAt?: string;
	blockwise?: boolean;
	keepSpaces?: boolean;
	replace?: boolean;
	keepCursor?: boolean;
};
export type ActionArgs = ActionArgsPartial & {
	repeat: number;
};
export type ActionFn = (cm: CodeMirrorV, actionArgs: ActionArgs, vim: vimState) => void;
export type MotionArgsPartial = {
	repeat?: number;
	forward?: boolean;
	selectedCharacter?: string;
	linewise?: boolean;
	textObjectInner?: boolean;
	sameLine?: boolean;
	repeatOffset?: number;
	toJumplist?: boolean;
	inclusive?: boolean;
	wordEnd?: boolean;
	toFirstChar?: boolean;
	explicitRepeat?: boolean;
	bigWord?: boolean;
	repeatIsExplicit?: boolean;
	noRepeat?: boolean;
};
export type MotionArgs = MotionArgsPartial & {
	repeat: number;
};
export type MotionFn = (cm: CodeMirrorV, head: Pos, motionArgs: MotionArgs, vim: vimState, inputState: InputStateInterface) => Pos | [
	Pos,
	Pos
] | null | undefined;
export type optionCallback = (value?: string | undefined, cm?: CodeMirror) => any;
export type booleanOptionCallback = (value?: boolean, cm?: CodeMirror) => any;
export type numberOptionCallback = (value?: number, cm?: CodeMirror) => any;
export type stringOptionCallback = (value?: string, cm?: CodeMirror) => any;
export type vimOption = {
	type?: string;
	defaultValue?: unknown;
	callback?: optionCallback;
	value?: unknown;
} | {
	type: "boolean";
	defaultValue?: boolean | null | undefined;
	callback?: booleanOptionCallback;
	value?: boolean;
};
export type ExFn = (cm: CodeMirrorV, params: ExParams) => void;
export type allCommands = {
	keys: string;
	context?: string;
	interlaceInsertRepeat?: boolean;
	exitVisualBlock?: boolean;
	isEdit?: boolean;
	repeatOverride?: number;
	noremap?: boolean;
};
export type motionCommand = allCommands & {
	type: "motion";
	motion: string;
	motionArgs?: MotionArgsPartial;
	repeatOverride?: number;
};
export type operatorCommand = allCommands & {
	type: "operator";
	operator: string;
	operatorArgs?: OperatorArgs;
};
export type actionCommand = allCommands & {
	type: "action";
	action: string;
	actionArgs?: ActionArgsPartial;
	motion?: string;
	operator?: string;
	interlaceInsertRepeat?: boolean;
};
export type searchCommand = allCommands & {
	type: "search";
	searchArgs: SearchArgs;
};
export type operatorMotionCommand = allCommands & {
	type: "operatorMotion";
	motion: string;
	operator: string;
	motionArgs?: MotionArgsPartial;
	operatorArgs?: OperatorArgs;
	operatorMotionArgs?: {
		visualLine?: boolean;
	};
};
export type idleCommand = allCommands & {
	type: "idle";
};
export type exCommand = allCommands & {
	type: "ex";
};
export type keyToExCommand = allCommands & {
	type: "keyToEx";
	exArgs: ExParams;
};
export type keyToKeyCommand = allCommands & {
	toKeys: string;
	type: "keyToKey";
};
export type vimKey = motionCommand | operatorCommand | actionCommand | searchCommand | operatorMotionCommand | idleCommand | exCommand | keyToExCommand | keyToKeyCommand;
export interface InputStateInterface {
	prefixRepeat: string[];
	motionRepeat: string[];
	operator: string | undefined | null;
	operatorArgs: OperatorArgs | undefined | null;
	motion: string | undefined | null;
	motionArgs: MotionArgs | null;
	keyBuffer: string[];
	registerName?: string;
	changeQueue: null | {
		inserted: string;
		removed: string[];
	};
	operatorShortcut?: string;
	selectedCharacter?: string;
	repeatOverride?: number;
	changeQueueList?: (InputStateInterface["changeQueue"])[];
	pushRepeatDigit(n: string): void;
	getRepeat(): number;
}
export interface SearchStateInterface {
	setReversed(reversed: boolean): void;
	isReversed(): boolean | undefined;
	getQuery(): RegExp;
	setQuery(query: string | RegExp): void;
	highlightTimeout: number | undefined;
	getOverlay(): {
		query: RegExp;
	};
	getScrollbarAnnotate(): any;
	setScrollbarAnnotate(query: RegExp | null): void;
	setOverlay(overlay: {
		query: RegExp;
	} | null): void;
}
export type InsertModeKey = InstanceType<Vim["InsertModeKey"]>;
export type InsertModeChanges = {
	changes: (InsertModeKey | string | [
		string,
		number?
	])[];
	expectCursorActivityForChange: boolean;
	visualBlock?: number;
	maybeReset?: boolean;
	ignoreCount?: number;
	repeatOverride?: number;
};
export type ExParams = {
	commandName: string;
	argString: string;
	input: string;
	args?: string[];
	line: number;
	lineEnd?: number;
	selectionLine: number;
	selectionLineEnd?: number;
	setCfg?: Object;
	callback?: () => void;
};
declare class Pos$1 {
	line: number;
	ch: number;
	sticky?: string;
	constructor(line: number, ch: number);
}
declare function on(emitter: any, type: string, f: Function): void;
declare function off(emitter: any, type: string, f: Function): void;
declare function signal(emitter: any, type: string, ...args: any[]): void;
export interface Operation {
	$d: number;
	isVimOp?: boolean;
	cursorActivityHandlers?: Function[];
	cursorActivity?: boolean;
	lastChange?: any;
	change?: any;
	changeHandlers?: Function[];
	$changeStart?: number;
}
export declare class CodeMirror {
	static isMac: boolean;
	static Pos: typeof Pos$1;
	static StringStream: StringStream & {
		new (_: string): StringStream;
	};
	static commands: {
		cursorCharLeft: (cm: CodeMirror) => void;
		redo: (cm: CodeMirror) => void;
		undo: (cm: CodeMirror) => void;
		newlineAndIndent: (cm: CodeMirror) => void;
		indentAuto: (cm: CodeMirror) => void;
		newlineAndIndentContinueComment: any;
		save: any;
	};
	static isWordChar: (ch: string) => boolean;
	static keys: any;
	static addClass: (el: any, str: string) => void;
	static rmClass: (el: any, str: string) => void;
	static e_preventDefault: (e: Event) => void;
	static e_stop: (e: Event) => void;
	static lookupKey: (key: string, map: string, handle: Function) => void;
	static on: typeof on;
	static off: typeof off;
	static signal: typeof signal;
	openDialog(template: Element, callback: Function | undefined, options: any): (newVal?: string) => void;
	openNotification(template: Node, options: NotificationOptions$1): () => void;
	static findMatchingTag: typeof findMatchingTag;
	static findEnclosingTag: typeof findEnclosingTag;
	cm6: EditorView;
	state: {
		statusbar?: Element | null;
		dialog?: HTMLElement | null;
		vimPlugin?: any;
		vim?: vimState | null;
		currentNotificationClose?: Function | null;
		closeVimNotification?: Function | null;
		keyMap?: string;
		overwrite?: boolean;
		textwidth?: number;
	};
	marks: Record<string, Marker$1>;
	$mid: number;
	curOp: Operation | null | undefined;
	options: any;
	_handlers: any;
	constructor(cm6: EditorView);
	on(type: string, f: Function): void;
	off(type: string, f: Function): void;
	signal(type: string, e: any, handlers?: any): void;
	indexFromPos(pos: Pos$1): number;
	posFromIndex(offset: number): Pos$1;
	foldCode(pos: Pos$1): void;
	firstLine(): number;
	lastLine(): number;
	lineCount(): number;
	setCursor(line: number, ch: number): void;
	setCursor(line: Pos$1): void;
	getCursor(p?: "head" | "anchor" | "start" | "end"): Pos$1;
	listSelections(): {
		anchor: Pos$1;
		head: Pos$1;
	}[];
	setSelections(p: CM5RangeInterface[], primIndex?: number): void;
	setSelection(anchor: Pos$1, head: Pos$1, options?: any): void;
	getLine(row: number): string;
	getLineHandle(row: number): {
		row: number;
		index: number;
	};
	getLineNumber(handle: any): number | null;
	releaseLineHandles(): void;
	getRange(s: Pos$1, e: Pos$1): string;
	replaceRange(text: string, s: Pos$1, e?: Pos$1, source?: string): void;
	replaceSelection(text: string): void;
	replaceSelections(replacements: string[]): void;
	getSelection(): string;
	getSelections(): string[];
	somethingSelected(): boolean;
	getInputField(): HTMLElement;
	clipPos(p: Pos$1): Pos$1;
	getValue(): string;
	setValue(text: string): void;
	focus(): void;
	blur(): void;
	defaultTextHeight(): number;
	findMatchingBracket(pos: Pos$1, _options?: any): {
		to: Pos$1;
	} | {
		to: undefined;
	};
	scanForBracket(pos: Pos$1, dir: 1 | -1, style: any, config: any): false | {
		pos: Pos$1;
		ch: string;
	} | null;
	indentLine(line: number, more?: boolean): void;
	indentMore(): void;
	indentLess(): void;
	execCommand(name: string): void;
	setBookmark(cursor: Pos$1, options?: {
		insertLeft: boolean;
	}): Marker$1;
	cm6Query?: SearchQuery;
	addOverlay({ query }: {
		query: RegExp;
	}): SearchQuery | undefined;
	removeOverlay(overlay?: any): void;
	getSearchCursor(query: RegExp, pos: Pos$1): {
		findNext: () => string[] | null | undefined;
		findPrevious: () => string[] | null | undefined;
		find: (back?: boolean) => string[] | null | undefined;
		from: () => Pos$1 | undefined;
		to: () => Pos$1 | undefined;
		replace: (text: string) => void;
		readonly match: string[] | null;
	};
	findPosV(start: Pos$1, amount: number, unit: "page" | "line", goalColumn?: number): Pos$1 & {
		hitSide?: boolean;
	};
	charCoords(pos: Pos$1, mode: "div" | "local"): {
		left: number;
		top: number;
		bottom: number;
	};
	coordsChar(coords: {
		left: number;
		top: number;
	}, mode: "div" | "local"): Pos$1;
	getScrollInfo(): {
		left: number;
		top: number;
		height: number;
		width: number;
		clientHeight: number;
		clientWidth: number;
	};
	scrollTo(x?: number | null, y?: number | null): void;
	scrollIntoView(pos?: Pos$1, margin?: number): void;
	getWrapperElement(): HTMLElement;
	getMode(): {
		name: string | number | boolean | undefined;
	};
	setSize(w: number, h: number): void;
	refresh(): void;
	destroy(): void;
	getLastEditEnd(): Pos$1;
	$lastChangeEndOffset: number;
	$lineHandleChanges: undefined | ViewUpdate[];
	onChange(update: ViewUpdate): void;
	onSelectionChange(): void;
	operation<T>(fn: () => T, force?: boolean): T;
	onBeforeEndOperation(): void;
	moveH(increment: number, unit: string): void;
	setOption(name: string, val: any): void;
	getOption(name: "firstLineNumber" | "tabSize" | "textwidth"): number;
	getOption(name: string): number | boolean | string | undefined;
	toggleOverwrite(on: boolean): void;
	getTokenTypeAt(pos: Pos$1): "" | "string" | "comment";
	overWriteSelection(text: string): void;
	/*** multiselect ****/
	isInMultiSelectMode(): boolean;
	virtualSelectionMode(): boolean;
	virtualSelection: Mutable<EditorSelection> | null;
	forEachSelection(command: Function): void;
	hardWrap(options: hardWrapOptions): number;
	showMatchesOnScrollbar?: Function;
	save?: Function;
	static keyName?: Function;
}
export type Mutable<Type> = {
	-readonly [Key in keyof Type]: Type[Key];
};
interface NotificationOptions$1 {
	bottom?: boolean;
	duration?: number;
}
declare function findMatchingTag(cm: CodeMirror, pos: Pos$1): null;
declare function findEnclosingTag(cm: CodeMirror, pos: Pos$1): {
	open: {
		from: Pos$1;
		to: Pos$1;
	};
	close: {
		from: Pos$1;
		to: Pos$1;
	};
} | undefined;
declare class Marker$1 {
	cm: CodeMirror;
	id: number;
	offset: number | null;
	assoc: number;
	constructor(cm: CodeMirror, offset: number, assoc: number);
	clear(): void;
	find(): Pos$1 | null;
	update(change: ChangeDesc): void;
}
export type hardWrapOptions = {
	from: number;
	to: number;
	column?: number;
	allowMerge?: boolean;
};
declare const Vim$1: {
	enterVimMode: (cm: CodeMirror) => void;
	leaveVimMode: (cm: CodeMirror) => void;
	buildKeyMap: () => void;
	getRegisterController: () => {
		registers: {
			[x: string]: {
				keyBuffer: string[];
				insertModeChanges: InsertModeChanges[];
				searchQueries: string[];
				linewise: boolean;
				blockwise: boolean;
				setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
				pushText(text: string, linewise?: boolean): void;
				pushInsertModeChanges(changes: InsertModeChanges): void;
				pushSearchQuery(query: string): void;
				clear(): void;
				toString(): string;
			};
		};
		unnamedRegister: {
			keyBuffer: string[];
			insertModeChanges: InsertModeChanges[];
			searchQueries: string[];
			linewise: boolean;
			blockwise: boolean;
			setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
			pushText(text: string, linewise?: boolean): void;
			pushInsertModeChanges(changes: InsertModeChanges): void;
			pushSearchQuery(query: string): void;
			clear(): void;
			toString(): string;
		};
		pushText(registerName: string | null | undefined, operator: string, text: string, linewise?: boolean, blockwise?: boolean): void;
		getRegister(name?: string): {
			keyBuffer: string[];
			insertModeChanges: InsertModeChanges[];
			searchQueries: string[];
			linewise: boolean;
			blockwise: boolean;
			setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
			pushText(text: string, linewise?: boolean): void;
			pushInsertModeChanges(changes: InsertModeChanges): void;
			pushSearchQuery(query: string): void;
			clear(): void;
			toString(): string;
		};
		isValidRegister(name: any): name is string;
		shiftNumericRegisters_(): void;
	};
	resetVimGlobalState_: () => void;
	getVimGlobalState_: () => {
		macroModeState: {
			latestRegister: string | undefined;
			isPlaying: boolean;
			isRecording: boolean;
			replaySearchQueries: string[];
			onRecordingDone: ((newVal?: string) => void) | undefined;
			lastInsertModeChanges: InsertModeChanges;
			exitMacroRecordMode(): void;
			enterMacroRecordMode(cm: CodeMirror, registerName: string): void;
		};
		registerController: {
			registers: {
				[x: string]: {
					keyBuffer: string[];
					insertModeChanges: InsertModeChanges[];
					searchQueries: string[];
					linewise: boolean;
					blockwise: boolean;
					setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
					pushText(text: string, linewise?: boolean): void;
					pushInsertModeChanges(changes: InsertModeChanges): void;
					pushSearchQuery(query: string): void;
					clear(): void;
					toString(): string;
				};
			};
			unnamedRegister: {
				keyBuffer: string[];
				insertModeChanges: InsertModeChanges[];
				searchQueries: string[];
				linewise: boolean;
				blockwise: boolean;
				setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
				pushText(text: string, linewise?: boolean): void;
				pushInsertModeChanges(changes: InsertModeChanges): void;
				pushSearchQuery(query: string): void;
				clear(): void;
				toString(): string;
			};
			pushText(registerName: string | null | undefined, operator: string, text: string, linewise?: boolean, blockwise?: boolean): void;
			getRegister(name?: string): {
				keyBuffer: string[];
				insertModeChanges: InsertModeChanges[];
				searchQueries: string[];
				linewise: boolean;
				blockwise: boolean;
				setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
				pushText(text: string, linewise?: boolean): void;
				pushInsertModeChanges(changes: InsertModeChanges): void;
				pushSearchQuery(query: string): void;
				clear(): void;
				toString(): string;
			};
			isValidRegister(name: any): name is string;
			shiftNumericRegisters_(): void;
		};
		searchHistoryController: {
			historyBuffer: string[];
			iterator: number;
			initialPrefix: string | null;
			nextMatch(input: string, up: boolean): string | undefined;
			pushInput(input: string): void;
			reset(): void;
		};
		jumpList: ReturnType<() => {
			cachedCursor: Pos | undefined;
			add: (cm: CodeMirror, oldCur: Pos, newCur: Pos) => void;
			find: (cm: CodeMirror, offset: number) => {
				line: number;
				ch: number;
				sticky?: string;
			} | null | undefined;
			move: (cm: CodeMirror, offset: number) => {
				cm: CodeMirror;
				id: number;
				offset: number | null;
				assoc: number;
				clear(): void;
				find(): {
					line: number;
					ch: number;
					sticky?: string;
				} | null;
				update(change: import("@codemirror/state").ChangeDesc): void;
			} | undefined;
		}>;
		exCommandHistoryController: {
			historyBuffer: string[];
			iterator: number;
			initialPrefix: string | null;
			nextMatch(input: string, up: boolean): string | undefined;
			pushInput(input: string): void;
			reset(): void;
		};
		lastCharacterSearch: {
			increment: number;
			forward: boolean;
			selectedCharacter: string;
		};
		query?: any;
		isReversed?: boolean;
		lastSubstituteReplacePart: any;
		searchQuery?: null;
		searchIsReversed?: boolean;
	};
	maybeInitVimState_: (cm: CodeMirror) => vimState;
	suppressErrorLogging: boolean;
	InsertModeKey: {
		new (keyName: string, e: KeyboardEvent): {
			keyName: string;
			key: string;
			ctrlKey: boolean;
			altKey: boolean;
			metaKey: boolean;
			shiftKey: boolean;
		};
	};
	map: (lhs: string, rhs: string, ctx: string) => void;
	unmap: (lhs: string, ctx: string) => any;
	noremap: (lhs: string, rhs: string, ctx: string) => void;
	mapclear: (ctx?: string) => void;
	langmap: (langmapString: any, remapCtrl: any) => void;
	vimKeyFromEvent: (e: KeyboardEvent, vim?: vimState) => string | undefined;
	setOption: (name: string, value: any, cm?: CodeMirrorV, cfg?: {
		scope?: any;
	} | undefined) => Error | undefined;
	getOption: (name: string, cm?: CodeMirrorV, cfg?: {
		scope?: any;
	} | undefined) => any;
	defineOption: {
		/**
		 * @overload
		 * @arg {string} name
		 * @arg {boolean|null|undefined} defaultValue
		 * @arg {'boolean'} type
		 * @arg {string[]|null} [aliases]
		 * @arg {import("./types").booleanOptionCallback} [callback]
		 * @returns {void}
		 */
		(name: string, defaultValue: boolean | null | undefined, type: "boolean", aliases?: string[] | null | undefined, callback?: booleanOptionCallback | undefined): void;
		/**
		 * @overload
		 * @arg {string} name
		 * @arg {number|null|undefined} defaultValue
		 * @arg {'number'} type
		 * @arg {string[]|null} [aliases]
		 * @arg {import("./types").numberOptionCallback} [callback]
		 * @returns {void}
		 */
		(name: string, defaultValue: number | null | undefined, type: "number", aliases?: string[] | null | undefined, callback?: numberOptionCallback | undefined): void;
		/**
		 * @overload
		 * @arg {string} name
		 * @arg {string|null|undefined} defaultValue
		 * @arg {'string'} type
		 * @arg {string[]|null} [aliases]
		 * @arg {import("./types").stringOptionCallback} [callback]
		 * @returns {void}
		 */
		(name: string, defaultValue: string | null | undefined, type: "string", aliases?: string[] | null | undefined, callback?: stringOptionCallback | undefined): void;
	};
	defineEx: (name: string, prefix: string | undefined, func: ExFn) => void;
	handleKey: (cm: CodeMirror, key: string, origin: string) => undefined | boolean;
	multiSelectHandleKey: (cm_: CodeMirror, key: string, origin: string) => boolean | undefined;
	findKey: (cm_: CodeMirror, key: string, origin?: string | undefined) => (() => boolean | undefined) | undefined;
	handleEx: (cm: CodeMirrorV, input: string) => void;
	defineMotion: (name: string, fn: MotionFn) => void;
	defineAction: (name: string, fn: ActionFn) => void;
	defineOperator: (name: string, fn: OperatorFn) => void;
	mapCommand: (keys: string, type: string, name: string, args: any, extra: {
		[x: string]: any;
	}) => void;
	_mapCommand: (command: vimKey) => void;
	defineRegister: (name: string, register: {
		keyBuffer: string[];
		insertModeChanges: InsertModeChanges[];
		searchQueries: string[];
		linewise: boolean;
		blockwise: boolean;
		setText(text?: string, linewise?: boolean, blockwise?: boolean): void;
		pushText(text: string, linewise?: boolean): void;
		pushInsertModeChanges(changes: InsertModeChanges): void;
		pushSearchQuery(query: string): void;
		clear(): void;
		toString(): string;
	}) => void;
	exitVisualMode: (cm: CodeMirrorV, moveHead?: boolean) => void;
	exitInsertMode: (cm: CodeMirrorV, keepCursor?: boolean) => void;
};
export declare function vim(options?: {
	status?: boolean;
}): Extension;
export declare function getCM(view: EditorView): CodeMirror | null;

export {
	Vim$1 as Vim,
};

export {};
